<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/gruntjs/grunt-contrib-concat#readme"

    >grunt-contrib-concat (v1.0.1)</a>
</h1>
<h4>Concatenate files.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-contrib-concat">module grunt-contrib-concat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-contrib-concat.grunt-contrib-concat">
            function <span class="apidocSignatureSpan"></span>grunt-contrib-concat
            <span class="apidocSignatureSpan">(grunt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-contrib-concat.</span>comment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">grunt-contrib-concat.</span>sourcemap</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-contrib-concat.comment">module grunt-contrib-concat.comment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-contrib-concat.comment.init">
            function <span class="apidocSignatureSpan">grunt-contrib-concat.comment.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.grunt-contrib-concat.sourcemap">module grunt-contrib-concat.sourcemap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.grunt-contrib-concat.sourcemap.init">
            function <span class="apidocSignatureSpan">grunt-contrib-concat.sourcemap.</span>init
            <span class="apidocSignatureSpan">(grunt)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-contrib-concat" id="apidoc.module.grunt-contrib-concat">module grunt-contrib-concat</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-contrib-concat.grunt-contrib-concat" id="apidoc.element.grunt-contrib-concat.grunt-contrib-concat">
        function <span class="apidocSignatureSpan"></span>grunt-contrib-concat
        <span class="apidocSignatureSpan">(grunt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">grunt-contrib-concat = function (grunt) {

  // Internal lib.
  var comment = require(&#x27;./lib/comment&#x27;).init(grunt);
  var chalk = require(&#x27;chalk&#x27;);
  var sourcemap = require(&#x27;./lib/sourcemap&#x27;).init(grunt);

  grunt.registerMultiTask(&#x27;concat&#x27;, &#x27;Concatenate files.&#x27;, function() {
    // Merge task-specific and/or target-specific options with these defaults.
    var options = this.options({
      separator: grunt.util.linefeed,
      banner: &#x27;&#x27;,
      footer: &#x27;&#x27;,
      stripBanners: false,
      process: false,
      sourceMap: false,
      sourceMapName: undefined,
      sourceMapStyle: &#x27;embed&#x27;
    });

    // Normalize boolean options that accept options objects.
    if (options.stripBanners === true) {
      options.stripBanners = {};
    }
    if (options.process === true) {
      options.process = {};
    }

    // Process banner and footer.
    var banner = grunt.template.process(options.banner);
    var footer = grunt.template.process(options.footer);

    // Set a local variable for whether to build source maps or not.
    var sourceMap = options.sourceMap;

    // If content is not embedded and it will be modified, either exit or do
    // not make the source map.
    if (
      sourceMap &#x26;&#x26; options.sourceMapStyle === &#x27;link&#x27; &#x26;&#x26;
        (options.stripBanners || options.process)
    ) {
      // Warn and exit if --force isn&#x27;t set.
      grunt.warn(
        &#x27;stripBanners or process option is enabled. &#x27; +
        &#x27;Set sourceMapStyle option to \&#x27;embed\&#x27; or \&#x27;inline\&#x27;.&#x27;
      );
      // --force is set, continue on without the source map.
      grunt.log.warn(&#x27;Skipping creation of source maps.&#x27;);
      // Set sourceMap to false to keep maps from being constructed.
      sourceMap = false;
    }

    // Iterate over all src-dest file pairs.
    this.files.forEach(function(f) {
      // Initialize source map objects.
      var sourceMapHelper;
      if (sourceMap) {
        sourceMapHelper = sourcemap.helper(f, options);
        sourceMapHelper.add(banner);
      }

      // Concat banner + specified files + footer.
      var src = banner + f.src.filter(function(filepath) {
        // Warn on and remove invalid source files (if nonull was set).
        if (!grunt.file.exists(filepath)) {
          grunt.log.warn(&#x27;Source file &#x22;&#x27; + filepath + &#x27;&#x22; not found.&#x27;);
          return false;
        }
        return true;
      }).map(function(filepath, i) {
        if (grunt.file.isDir(filepath)) {
          return;
        }
        // Read file source.
        var src = grunt.file.read(filepath);
        // Process files as templates if requested.
        if (typeof options.process === &#x27;function&#x27;) {
          src = options.process(src, filepath);
        } else if (options.process) {
          src = grunt.template.process(src, options.process);
        }
        // Strip banners if requested.
        if (options.stripBanners) {
          src = comment.stripBanner(src, options.stripBanners);
        }
        // Add the lines of this file to our map.
        if (sourceMapHelper) {
          src = sourceMapHelper.addlines(src, filepath);
          if (i &#x3c; f.src.length - 1) {
            sourceMapHelper.add(options.separator);
          }
        }
        return src;
      }).join(options.separator) + footer;

      if (sourceMapHelper) {
        sourceMapHelper.add(footer);
        sourceMapHelper.write();
        // Add sourceMappingURL to the end.
        src += sourceMapHelper.url();
      }

      // Write the destination file.
      grunt.file.write(f.dest, src);

      // Print a success message.
      grunt.verbose.write(&#x27;File &#x27; + chalk.cyan(f.dest) + &#x27; created.&#x27;);
    });
  });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-contrib-concat.comment" id="apidoc.module.grunt-contrib-concat.comment">module grunt-contrib-concat.comment</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-contrib-concat.comment.init" id="apidoc.element.grunt-contrib-concat.comment.init">
        function <span class="apidocSignatureSpan">grunt-contrib-concat.comment.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
  var exports = {};

  // Return the given source code with any leading banner comment stripped.
  exports.stripBanner = function(src, options) {
    if (!options) {
      options = {};
    }

    var m = [];
    if (options.line) {
      // Strip // ... leading banners.
      m.push(&#x27;(?:.*\\/\\/.*\\r?\\n)+\\s*&#x27;);
    }
    if (options.block) {
      // Strips all /* ... */ block comment banners.
      m.push(&#x27;\\/\\*[\\s\\S]*?\\*\\/&#x27;);
    } else {
      // Strips only /* ... */ block comment banners, excluding /*! ... */.
      m.push(&#x27;\\/\\*[^!][\\s\\S]*?\\*\\/&#x27;);
    }
    var re = new RegExp(&#x27;^\\s*(?:&#x27; + m.join(&#x27;|&#x27;) + &#x27;)\\s*&#x27;, &#x27;&#x27;);
    return src.replace(re, &#x27;&#x27;);
  };

  return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.grunt-contrib-concat.sourcemap" id="apidoc.module.grunt-contrib-concat.sourcemap">module grunt-contrib-concat.sourcemap</a></h1>


    <h2>
        <a href="#apidoc.element.grunt-contrib-concat.sourcemap.init" id="apidoc.element.grunt-contrib-concat.sourcemap.init">
        function <span class="apidocSignatureSpan">grunt-contrib-concat.sourcemap.</span>init
        <span class="apidocSignatureSpan">(grunt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (grunt) {
  var exports = {};

  // Node first party libs
  var path = require(&#x27;path&#x27;);

  // Third party libs
  var chalk = require(&#x27;chalk&#x27;);
  var SourceMap = require(&#x27;source-map&#x27;);
  var SourceMapConsumer = SourceMap.SourceMapConsumer;
  var SourceMapGenerator = SourceMap.SourceMapGenerator;

  var NO_OP = function(){};

  function SourceMapConcatHelper(options) {
    this.files = options.files;
    this.dest = options.dest;
    this.options = options.options;
    this.line = 1;
    this.column = 0;

    // ensure we&#x27;re using forward slashes, because these are URLs
    var file = path.relative(path.dirname(this.dest), this.files.dest).replace(/\\/g, &#x27;/&#x27;);
    var generator = new SourceMapGenerator({
      file: file
    });
    this.file = file;
    this.generator = generator;
    this.addMapping = function(genLine, genCol, orgLine, orgCol, source, name) {
      if (!source) {
        generator.addMapping({
          generated: {line: genLine, column: genCol}
        });
      } else {
        if (!name) {
          generator.addMapping({
            generated: {line: genLine, column: genCol},
            original: {line: orgLine, column: orgCol},
            source: source
          });
        } else {
          generator.addMapping({
            generated: {line: genLine, column: genCol},
            original: {line: orgLine, column: orgCol},
            source: source,
            name: name
          });
        }
      }
    };
  }

  // Return an object that is used to track sourcemap data between calls.
  exports.helper = function(files, options) {
    // Figure out the source map destination.
    var dest = files.dest;
    if (options.sourceMapStyle === &#x27;inline&#x27;) {
      // Leave dest as is. It will be used to compute relative sources.
    } else if (typeof options.sourceMapName === &#x27;string&#x27;) {
      dest = options.sourceMapName;
    } else if (typeof options.sourceMapName === &#x27;function&#x27;) {
      dest = options.sourceMapName(dest);
    } else {
      dest += &#x27;.map&#x27;;
    }

    // Inline style and sourceMapName together doesn&#x27;t work
    if (options.sourceMapStyle === &#x27;inline&#x27; &#x26;&#x26; options.sourceMapName) {
      grunt.log.warn(
        &#x27;Source map will be inlined, sourceMapName option ignored.&#x27;
      );
    }

    return new SourceMapConcatHelper({
      files: files,
      dest: dest,
      options: options
    });
  };

  // Parse only to increment the generated file&#x27;s column and line count
  SourceMapConcatHelper.prototype.add = function(src) {
    this._forEachTokenPosition(src);
  };

<span class="apidocCodeCommentSpan">  /**
   * Parse the source file into tokens and apply the provided callback
   * with the position of the token boundaries in the original file, and
   * in the generated file.
   *
   * @param src The sources to tokenize. Required
   * @param filename The name of the source file. Optional
   * @param callback What to do with the token position indices. Optional
   */
</span>  SourceMapConcatHelper.prototype._forEachTokenPosition = function(src, filename, callback) {
    var genLine = this.line;
    var genCol = this.column;
    var orgLine = 1;
    var orgCol = 0;
    // Tokenize on words, new lines, and white space.
    var tokens = src.split(/(\n|[^\S\n]+|\b)/g);
    if (!callback) {
      callback = NO_OP;
    }
    for (var i = 0, len = tokens.length; i &#x3c; len; i++) {
      var token = tokens[i];
      if (token) {
        // The if statement filters out empty strings.
        callback(genLine, genCol, orgLine, orgCol, filename);
        if (token === &#x27;\n&#x27;) {
          ++orgLine;
          ++genLine;
          orgCol = 0;
          genCol = 0;
        } else {
          orgCol += token.length;
          genCol += token.length;
        }
      }
    }

    this.line = genLine;
    this.column = genCol;
  };

  // Add the lines of a given file to the sourcemap. If in the file, store a
  // prior sourcemap and return src with sourceMappingURL removed.
  SourceMapConcatHelper.prototype.addlines = function(src, filename) {
    var sourceMapRegEx = /\n\/[*/][@#]\s+sourceMappingURL=((?:(?!\s+\*\/).)*).*/;
    var relativeFilena ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
